doc
"faster algorithms for longest common substring. in the classic longest common substring (lcs) problem, we are given two strings $s$ and $t$, each of length at most $n$, over an alphabet of size $\sigma$, and we are asked to find a longest string occurring as a fragment of both $s$ and $t$. weiner, in his seminal paper that introduced the suffix tree, presented an $o(n \log \sigma)$-time algorithm for this problem [swat 1973]. for polynomially-bounded integer alphabets, the linear-time construction of suffix trees by farach yielded an $o(n)$-time algorithm for the lcs problem [focs 1997]. however, for small alphabets, this is not necessarily optimal for the lcs problem in the word ram model of computation, in which the strings can be stored in $o(n \log \sigma/\log n )$ space and read in $o(n \log \sigma/\log n )$ time. we show that, in this model, we can compute an lcs in time $o(n \log \sigma / \sqrt{\log n})$, which is sublinear in $n$ if $\sigma=2^{o(\sqrt{\log n})}$ (in particular, if $\sigma=o(1)$), using optimal space $o(n \log \sigma/\log n)$. in fact, it was recently shown that this result is conditionally optimal [kempa and kociumaka, stoc 2025]. we then lift our ideas to the problem of computing a $k$-mismatch lcs, which has received considerable attention in recent years. in this problem, the aim is to compute a longest substring of $s$ that occurs in $t$ with at most $k$ mismatches. thankachan et al.~showed how to compute a $k$-mismatch lcs in $o(n \log^k n)$ time for $k=o(1)$ [j. comput. biol. 2016]. we show an $o(n \log^{k-1/2} n)$-time algorithm, for any constant $k>0$ and irrespective of the alphabet size, using $o(n)$ space as the previous approaches. we thus notably break through the well-known $n \log^k n$ barrier, which stems from a recursive heavy-path decomposition technique that was first introduced in the seminal paper of cole et al. [stoc 2004] for string indexing with $k$ errors."
"random access to grammar compressed strings. grammar based compression, where one replaces a long string by a small context-free grammar that generates the string, is a simple and powerful paradigm that captures many popular compression schemes. in this paper, we present a novel grammar representation that allows efficient random access to any character or substring without decompressing the string. let $s$ be a string of length $n$ compressed into a context-free grammar $\mathcal{s}$ of size $n$. we present two representations of $\mathcal{s}$ achieving $o(\log n)$ random access time, and either $o(n\cdot \alpha_k(n))$ construction time and space on the pointer machine model, or $o(n)$ construction time and space on the ram. here, $\alpha_k(n)$ is the inverse of the $k^{th}$ row of ackermann's function. our representations also efficiently support decompression of any substring in $s$: we can decompress any substring of length $m$ in the same complexity as a single random access query and additional $o(m)$ time. combining these results with fast algorithms for uncompressed approximate string matching leads to several efficient algorithms for approximate string matching on grammar-compressed strings without decompression. for instance, we can find all approximate occurrences of a pattern $p$ with at most $k$ errors in time $o(n(\min\{|p|k, k^4 + |p|\} + \log n) + occ)$, where $occ$ is the number of occurrences of $p$ in $s$. finally, we generalize our results to navigation and other operations on grammar-compressed ordered trees. all of the above bounds significantly improve the currently best known results. to achieve these bounds, we introduce several new techniques and data structures of independent interest, including a predecessor data structure, two ""biased"" weighted ancestor data structures, and a compact representation of heavy paths in grammars."
"probabilistic threshold indexing for uncertain strings. strings form a fundamental data type in computer systems. string searching has been extensively studied since the inception of computer science. increasingly many applications have to deal with imprecise strings or strings with fuzzy information in them. string matching becomes a probabilistic event when a string contains uncertainty, i.e. each position of the string can have different probable characters with associated probability of occurrence for each character. such uncertain strings are prevalent in various applications such as biological sequence data, event monitoring and automatic ecg annotations. we explore the problem of indexing uncertain strings to support efficient string searching. in this paper we consider two basic problems of string searching, namely substring searching and string listing. in substring searching, the task is to find the occurrences of a deterministic string in an uncertain string. we formulate the string listing problem for uncertain strings, where the objective is to output all the strings from a collection of strings, that contain probable occurrence of a deterministic query string. indexing solution for both these problems are significantly more challenging for uncertain strings than for deterministic strings. given a construction time probability value $\tau$, our indexes can be constructed in linear space and supports queries in near optimal time for arbitrary values of probability threshold parameter greater than $\tau$. to the best of our knowledge, this is the first indexing solution for searching in uncertain strings that achieves strong theoretical bound and supports arbitrary values of probability threshold parameter. we also propose an approximate substring search index that can answer substring search queries with an additive error in optimal time. we conduct experiments to evaluate the performance of our indexes."
